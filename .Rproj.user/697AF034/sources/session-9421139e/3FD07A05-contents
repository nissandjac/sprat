mtrx = NULL,
Surveyobs = NULL,
Catchobs = NULL,
propM = NULL,
propF = NULL,
years,
startYear = min(years),
endYear = max(years),
nseason = 4,
nsurvey = dim(Surveyobs)[3],
ages = 0:20,
Fbarage = c(1, max(ages)),
recseason = 1,
Fminage = 0,
Fmaxage = max(ages),
Qminage = rep(0, nsurvey),
Qmaxage = rep(max(ages), nsurvey),
Qlastage = Qmaxage,
isFseason = rep(1, nseason),
CminageSeason = rep(0, nseason),
CmaxageSeason = rep(max(ages), nseason),
endFseason = nseason,
nocatch = matrix(rep(1, nseason), nrow = length(years), ncol = nseason),
useEffort = 0,
estimateCreep = 0,
effort = matrix(1, nrow = length(years), ncol = nseason),
blocks = FALSE,
surveyStart = rep(0, nsurvey),
surveyEnd = rep(1, nsurvey),
surveySeason = rep(1, nsurvey),
leavesurveyout = rep(1, nsurvey),
minSDsurvey = 0.1,
minSDcatch = 0.1,
maxSDcatch = sqrt(2),
peneps = 1e-3,
penepsC = 1e-3,
penepsCmax = 1e-3,
Mprior = -1,
SDMprior = 0.2,
powers = list(NA),
Pred_in = matrix(0),
M_min = 0,
M_max = max(ages),
scv = array(0, dim = c(length(ages), length(years), nsurvey)),
surveySD = replicate(nsurvey, 0, simplify = FALSE),
catchSD = replicate(nseason, 0, simplify = FALSE),
MCV = matrix(c(0, max(ages)), nrow = 2, ncol = 1),
prior_SDM = 0.4,
estSD = c(0, 0, 0),
SDmin = c(0.2, 0.2, 0.2),
betaSR = NULL,
nllfactor = rep(1, 3),
randomF = 0,
randomM = 0,
randomR = 0,
recmodel = 1,
nenv = 0,
warn = FALSE) {
  # Remove surveys for sensitivity analysis
  
  if (sum(leavesurveyout) != nsurvey) {
    
    Surveyobs <- Surveyobs[, , leavesurveyout == 1, drop = FALSE]
    Qminage <- Qminage[leavesurveyout == 1]
    Qmaxage <- Qmaxage[leavesurveyout == 1]
    Qlastage <- Qlastage[leavesurveyout == 1]
    powers <- powers[leavesurveyout == 1]
    surveySD <- surveySD[leavesurveyout == 1]
    nsurvey <- sum(leavesurveyout)
    surveySeason <- surveySeason[leavesurveyout == 1]
  }
  
  nsurvey <- dim(Surveyobs)[3]
  if (nsurvey == 0) {
    warning("probably doesnt work without survey")
  }
  
  if(length(years) == 1){
    stop('Input years as a vector')
  }
  
  nage <- length(ages)
  nyears <- length(years)
  
  if(any(surveySeason > nseason)){
    stop('List correct season for the survey')
  }
  
  # Do a sanity check of dimension sizes of input data
  
  
  
  exp_dim <- c(nage, nyear + 1, nseason)
  
  fix_dim <- function(arr, name, exp_dim, nage, nyear, nseason) {
    d <- dim(arr)
    
    # Already correct 3D
    if (length(d) == 3 && all(d == exp_dim)) return(arr)
    
    # Allow 4D with a singleton 3rd dim: c(nage, nyear+1, 1, nseason)
    if (length(d) == 4 && d[3] == 1 &&
        all(d[c(1, 2)] == exp_dim[1:2]) &&
        d[4] == exp_dim[3]) {
      
      # Drop only the 3rd (singleton) dim; result should be 3D
      arr <- arr[,,1, , drop = TRUE]
      
      if (length(dim(arr)) == 3 && all(dim(arr) == exp_dim)) return(arr)
      
      stop(sprintf("After squeezing singleton, %s still mismatched (got %s, expected %s).",
                   name, paste(dim(arr), collapse = "x"), paste(exp_dim, collapse = "x")))
    }
    
    stop(sprintf("Dimension mismatch of %s (got %s, expected %s).",
                 name, paste(d, collapse = "x"), paste(exp_dim, collapse = "x")))
  }
  
  # Apply
  if (all(dim(mtrx$weca) == c(nage, nyear, nseason))) {
    # Compute mean of last 5 years (across year dimension = 2)
    mean_last5 <- apply(mtrx$weca[, (nyear-4):nyear, , drop = FALSE], c(1, 3), mean, na.rm = TRUE)
    
    # Add as new "year + 1" slice
    mtrx$weca <- abind::abind(mtrx$weca, mean_last5, along = 2)
  }
  
  if (all(dim(mtrx$M) == c(nage, nyear, nseason))) {
    # Compute mean of last 5 years (across year dimension = 2)
    mean_last5 <- apply(mtrx$M[, (nyear-4):nyear, , drop = FALSE], c(1, 3), mean, na.rm = TRUE)
    
    # Add as new "year + 1" slice
    mtrx$M <- abind::abind(mtrx$M, mean_last5, along = 2)
  }
  if (all(dim(mtrx$west) == c(nage, nyear, nseason))) {
    # Compute mean of last 5 years (across year dimension = 2)
    mean_last5 <- apply(mtrx$west[, (nyear-4):nyear, , drop = FALSE], c(1, 3), mean, na.rm = TRUE)
    
    # Add as new "year + 1" slice
    mtrx$west <- abind::abind(mtrx$west, mean_last5, along = 2)
  }
  if (all(dim(mtrx$mat) == c(nage, nyear, nseason))) {
    # Compute mean of last 5 years (across year dimension = 2)
    mean_last5 <- apply(mtrx$mat[, (nyear-4):nyear, , drop = FALSE], c(1, 3), mean, na.rm = TRUE)
    
    # Add as new "year + 1" slice
    mtrx$mat <- abind::abind(mtrx$mat, mean_last5, along = 2)
  }
  
  
  mtrx$weca <- fix_dim(mtrx$weca, "weca", exp_dim, nage, nyear, nseason)
  mtrx$west <- fix_dim(mtrx$west, "west", exp_dim, nage, nyear, nseason)
  mtrx$M    <- fix_dim(mtrx$M,    "M",    exp_dim, nage, nyear, nseason)
  mtrx$mat  <- fix_dim(mtrx$mat,  "maturity", exp_dim, nage, nyear, nseason)
  
  # Now check survey
  if (any(dim(Surveyobs) != c(nage, nyears,nsurvey))) stop("Dimension mismatch of Survey.")
  
  # Now check Catches
  # Add the extra dimension if nseason == 1
  if(length(dim(Catchobs)) == 2){
    Catchobs <- array(Catchobs, dim = c(nage, nyears, 1))
  }
  
  
  if (any(dim(Catchobs) != c(nage, nyears,nseason))) stop("Dimension mismatch of catches.")
  
  # if(is.null(betaSR)){
  #   nllfactor[3] <- 0
  # }
  
  
  for(i in 1:nsurvey){
    if(surveyEnd[i] == surveyStart[i]){
      surveyEnd[i] <- surveyStart[i]*1.001 # Small hack
      
    }
  }
  
  
  Qidx <- rep(0, nsurvey)
  
  
  if(length(Qminage)<nsurvey){
    stop('Provide minimum age for all surveys (Qminage)')
  }
  
  if(length(Qlastage) < nsurvey){
    stop('Provide maximum age for all surveys (Qlastage)')
  }
  
  
  for(k in 1:nsurvey){
    
    if(min(surveySD[[k]]) > Qminage[k]){
      surveySD[[k]] <- c(Qminage[k], surveySD[[k]])
    }
    
  }
  
  
  if (nsurvey > 1) {
    for (i in 2:nsurvey) {
      Qidx[i] <- length(ages[ages == Qminage[i - 1]]:ages[ages == Qlastage[i - 1]]) + Qidx[i - 1]
    }
  } else {
    Qidx <- 0
  }
  
  
  
  # Fix the survey CV groups
  Qidx.CV <- matrix(0, nage, nsurvey)
  no <- 1
  maxage <- max(ages)
  
  for (k in 1:nsurvey) {
    #surveySD[[k]][1] <- Qminage[k]
    tmpCV <- surveySD[[k]] + 1 # Go from age to index
    vec <- rep(0, nage)
    
    if (length(tmpCV) == 1) {
      vec[tmpCV:(maxage + 1)] <- no
      no <- no + 1
    } else {
      for (i in 1:(length(tmpCV))) {
        if (i < length(tmpCV)) {
          tmp.idx <- tmpCV[i]:(tmpCV[i + 1] - 1)
          vec[tmp.idx] <- no
          no <- no + 1
        } else {
          vec[tmpCV[length(tmpCV)]:(tmpCV[i])] <- no # Test this with other models (tmpCV[i] + 1)
          no <- no + 1
        }
      }
      
      vec[max(tmpCV):nage] <- vec[max(tmpCV)]
    }
    
    # Expand the tmp CV into a nage length  vector
    
    rm.idx <- which(0:maxage < Qminage[k] | 0:maxage > Qmaxage[k])
    vec[rm.idx] <- -98
    Qidx.CV[, k] <- vec
  }
  
  
  Qidx.CV <- Qidx.CV - 1 # Scale to c++ indexing
  
  
  # Fix the M2 groups
  
  
  if(randomM == 1){
    
    if(M_max < max(MCV)){
      warning('discepancy between max M and M groups')
    }
    
    Midx.CV <- matrix(0, nage, 1)
    mobs <- 1
    maxage <- max(ages)
    
    tmpCV <- MCV + 1 # Go from age to index
    vec <- rep(0, nage)
    
    if (length(tmpCV) == 1) {
      vec[tmpCV:(maxage + 1)] <- mobs
      mobs <- mobs + 1
    } else {
      for (i in 1:(length(tmpCV))) {
        if (i < length(tmpCV)) {
          tmp.idx <- tmpCV[i]:(tmpCV[i + 1] - 1)
          vec[tmp.idx] <- mobs
          mobs <- mobs + 1
        } else {
          vec[tmpCV[length(tmpCV)]:(tmpCV[i] + 1)] <- mobs
          mobs <- mobs + 1
        }
      }
      
      vec[max(tmpCV):nage] <- vec[max(tmpCV)]
    }
    
    # Expand the tmp CV into a nage length  vector
    
    rm.idx <- which(0:maxage < MCV[1] | 0:maxage > M_max)
    vec[rm.idx] <- -98
    Midx.CV <- vec
    
    
    Midx.CV <- as.matrix(Midx.CV) - 1 # Scale to c++ indexing
  }else{
    Midx.CV <- matrix(1, 1) # Just so the model runs. Fix with nicer code later
  }
  
  if(randomM == 1 & length(Pred_in) > 1){stop('Random walk M and MICE does not work currently')}
  
  
  if(length(MCV) > 1){
    
    if(length(M_max) == 1){
      M_max <- rep(M_max, length(MCV))
    }
    
  }
  
  
  if(length(MCV) > 1){
    
    if(length(M_min) != length(MCV)){
      for(j in 1:length(MCV)){
        M_min[j] <- MCV[[j]][1]
      }
    }
  }
  
  
  
  
  if(length(Pred_in) > 1){
    
    Midx.CV <- matrix(0, nage, length(MCV))
    mobs <- 1
    maxage <- max(ages)
    
    for (k in 1:length(MCV)) {
      tmpCV <- MCV[[k]] + 1 # Go from age to index
      vec <- rep(0, nage)
      
      if (length(tmpCV) == 1) {
        vec[tmpCV:(maxage + 1)] <- mobs
        mobs <- mobs + 1
      } else {
        for (i in 1:(length(tmpCV))) {
          if (i < length(tmpCV)) {
            tmp.idx <- tmpCV[i]:(tmpCV[i + 1] - 1)
            vec[tmp.idx] <- mobs
            mobs <- mobs + 1
          } else {
            vec[tmpCV[length(tmpCV)]:(tmpCV[i] + 1)] <- mobs
            mobs <- mobs + 1
          }
        }
        
        vec[max(tmpCV):nage] <- vec[max(tmpCV)]
      }
      
      # Expand the tmp CV into a nage length  vector
      
      rm.idx <- which(0:maxage < M_min[k] | 0:maxage > M_max[k])
      vec[rm.idx] <- -98
      Midx.CV[, k] <- vec
    }
    
    
    Midx.CV <- as.matrix(Midx.CV) - 1 # Scale to c++ indexing
    
    
    
  }
  
  
  
  # Turn the block into an index
  effort.in <- matrix(0, nyear, nseason)
  
  
  if (blocks[1] != FALSE) {
    blocks.idx <- which(years %in% blocks) #
    # Extend the index to years
    bidx <- rep(NA, nyear)
    
    for (i in 1:(length(blocks.idx) - 1)) {
      len <- blocks.idx[i]:(blocks.idx[i + 1] - 1)
      bidx[len] <- i - 1
    }
    bidx[blocks.idx[length(blocks.idx)]:nyear] <- length(blocks.idx) - 1
    
    
    # Change mean effort to 1 (within blocks)
    nblocks <- length(blocks.idx)
    
    for (i in 1:nblocks) {
      tmpidx <- which((bidx + 1) == i)
      
      tmpeffort <- effort[tmpidx, ]
      
      Meffort <- sum(tmpeffort) / length(tmpeffort[tmpeffort > 0])
      
      effort.in[tmpidx, ] <- effort[tmpidx, ] / Meffort
      
      # }
    }
  } else {
    tmpeffort <- effort
    Meffort <- mean(tmpeffort[tmpeffort > 0])
    effort.in <- effort / Meffort
    bidx <- rep(0, nyear)
  }
  
  # Scale effort to 1
  
  # Add index to determine if b has several blocks
  
  if (all(blocks == FALSE)) {
    useBlocks <- 0
  } else {
    useBlocks <- 1
  }
  
  # if(all(effort != 1)){
  #   useEffort <- 1
  # }
  
  if (nseason > 1) {
    isFseason[length(isFseason)] <- 0 # This is a weird standard thing in sms
  }
  # Do the power law calcs
  if (is.na(powers[[1]])) {
    powersexp <- matrix(0, nrow = length(ages), ncol = nsurvey)
  } else {
    powersexp <- matrix(0, nrow = length(ages), ncol = nsurvey)
    
    for (i in 1:nsurvey) {
      if (is.na(powers[[i]]) == 0) {
        powersexp[powers[[i]] + 1, i] <- 1
      }
    }
  }
  
  
  
  # Fix the survey CV groups
  Cidx.CV <- matrix(NA, nage, nseason)
  
  if (min(CminageSeason) > Fminage) {
    Fminage <- min(CminageSeason)
  }
  
  
  # if(length(catchSD) > 1){
  for (i in 1:nseason) {
    if (min(catchSD[[i]]) != 0) {
      catchSD[[i]] <- c(0, catchSD[[i]])
    }
    
    
    if (i == 1) {
      #        if(min(catchSD[[i]])>0){
      no <- 1:length(catchSD[[i]])
      # }else{
      # no <- 0:(length(catchSD[[i]])-1)
      # }
    } else {
      no <- (max(no) + 1):(max(no) + length(catchSD[[i]]))
      
      no <- no - CminageSeason[i]
    }
    Cidx.CV[ages %in% catchSD[[i]], i] <- no
    Cidx.CV[ages > max(catchSD[[i]]), i] <- max(no)
    Cidx.CV[ages < min(catchSD[[i]]), i] <- min(no)
    
    
    # Do a loop for NA check
    for (a in 2:nage) {
      if (is.na(Cidx.CV[a, i])) {
        Cidx.CV[a, i] <- Cidx.CV[a - 1, i]
      }
    }
    
    if (CminageSeason[i] < Fminage) {
      CminageSeason[i] <- Fminage
    }
    
    
    Cidx.CV[ages < CminageSeason[i], i] <- -98
    Cidx.CV[ages > CmaxageSeason[i], i] <- -98
  }
  #
  #   }else{
  #
  #     for(i in 1:nseason){
  #
  #
  #       no <- 1:length(catchSD[[i]])
  #
  #       Cidx.CV[ages %in% catchSD[[i]],i] <- no
  #       Cidx.CV[ages > max(catchSD[[i]]),i] <- max(no)
  #       Cidx.CV[ages < min(catchSD[[i]]),i] <- min(no)
  #
  #       for(a in 2:nage){
  #         if(is.na(Cidx.CV[a, i])){
  #           Cidx.CV[a,i] <- Cidx.CV[a-1,i]
  #         }
  #       }
  #
  #       Cidx.CV[ages < CminageSeason[i],nseason] <- -98
  #       Cidx.CV[ages > CmaxageSeason[i],nseason] <- -98
  #
  #     }
  #
  #
  #
  #
  #   }
  
  if (min(Cidx.CV[Cidx.CV > 0]) == 1) { # Do some index fixing
    Cidx.CV <- Cidx.CV + 1
  }
  
  Cidx.CV <- Cidx.CV - 2 # Convert to C++ idx
  
  CVgroups <- NA
  
  for (i in 1:length(catchSD)) {
    CVgroups[i] <- length(catchSD[[i]])
  }
  
  
  # Do Catch CV for internal CV calcs
  # CCV.out <- array(unlist(catchSD), dim = c())
  
  if (length(unique(CVgroups)) > 1 & estSD[2] == 2) {
    stop("sms currently doesnt support multiple catch CVs between seasons with internally calculated SD")
  }
  
  catchSDout <- matrix(rep(catchSD[[1]], nseason), ncol = nseason)
  #
  #   if(estSD[2] == 2){
  #   catchSDout <- catchSD
  #
  #   }
  
  # Calc the number of catch observations
  
  no <- matrix(0, nrow = nrow(catchSDout), ncol = nseason)
  
  for (i in 1:nrow(catchSDout)) {
    for (qrts in 1:nseason) {
      if ((i - 1) >= CminageSeason[qrts]) {
        if (i < nrow(catchSDout)) {
          idx <- catchSDout[i]:(catchSDout[i + 1] - 1) + 1
        } else {
          idx <- (catchSDout[i] + 1):nage
        }
        
        Out <- Catchobs[idx, , qrts]
        
        no[i, qrts] <- length(Out[Out > 0])
      }
    }
  }
  
  if (nrow(catchSDout) == 1 & nseason == 1) {
    no[i, qrts] <- length(Catchobs[Catchobs > 0])
  }
  
  #  Catchobs[Catchobs <= 1] <- 0
  
  
  if (is.null(propM)) {
    propM <- array(0, dim = c(nage, nyear + 1, nseason))
  }
  
  if (is.null(propF)) {
    propF <- array(0, dim = c(nage, nyear + 1, nseason))
  }
  
  if(is.null(mtrx$M)){
    stop('Provide natural mortality')
  }
  
  
  if(is.null(dim(mtrx$M))){
    mtrx$M <- matrix(rep(mtrx$M, each = nage), nrow = nage, ncol = nyear+1)
    message('Turning M vector into age matrix')
  }
  
  
  if(length(mtrx$mat) == nage){
    mtrx$mat <- matrix(mtrx$mat, nrow = nage, ncol = nyear)
  }
  
  # Add a projection year to weca and west
  
  if(dim(mtrx$weca)[2] == nyear){
    
    weca.mean <- apply(mtrx$weca[,(nyear-2):nyear,, drop =FALSE], FUN = rowMeans, MAR = c(3))
    mtrx$weca <- abind::abind(mtrx$weca, array(weca.mean, dim = c(nage, 1, nseason) ), along = 2)
    
    if(warn == TRUE){
      warning('add projection year to weca. Using average of last 3 years')
    }
    
  }
  
  
  if(dim(mtrx$west)[2] == nyear){
    
    west.mean <- apply(mtrx$west[,(nyear-2):nyear,, drop =FALSE], FUN = rowMeans, MAR = c(3))
    mtrx$west <- abind::abind(mtrx$west,array(west.mean, dim = c(nage, 1, nseason) ), along = 2)
    if(warn == TRUE){
      
      warning('add projection year to weca. Using average of last 3 years')
      
    }
  }
  
  
  if(dim(mtrx$mat)[2] == nyear){
    
    mat.mean <- apply(mtrx$mat[,(nyear-2):nyear,, drop =FALSE], FUN = rowMeans, MAR = c(3))
    mtrx$mat <- abind::abind(mtrx$mat,array(mat.mean, dim = c(nage, 1, nseason) ), along = 2)
    if(warn == TRUE){
      
      warning('add projection year to mat. Using average of last 3 years')
    }
  }
  
  if(dim(mtrx$M)[2] == nyear){
    
    M.mean <- apply(mtrx$M[,(nyear-2):nyear,, drop =FALSE], FUN = rowMeans, MAR = c(3))
    mtrx$M <- abind::abind(mtrx$M,array(M.mean, dim = c(nage, 1, nseason) ), along = 2)
    if(warn == TRUE){
      
      warning('add projection year to M. Using average of last 3 years')
      
    }
  }
  
  if(dim(propM)[2] == nyear){
    
    propM.mean <- apply(propM[,(nyear-2):nyear,, drop =FALSE], FUN = rowMeans, MAR = c(3))
    propM <- abind::abind(propM,array(M.mean, dim = c(nage, 1, nseason) ), along = 2)
    if(warn == TRUE){
      
      warning('add projection year to propM. Using average of last 3 years')
      
    }
  }
  
  if(dim(propF)[2] == nyear){
    
    propF.mean <- apply(propF[,(nyear-2):nyear,, drop =FALSE], FUN = rowMeans, MAR = c(3))
    propF <- abind::abind(propF,array(M.mean, dim = c(nage, 1, nseason) ), along = 2)
    if(warn == TRUE){
      
      warning('add projection year to propF. Using average of last 3 years')
      
    }
  }
  
  # Add dimension names to variables
  
  dnames <- list(ages = ages, years = c(years, max(years)+1), seasons = 1:nseason)
  
  dimnames(mtrx$weca) <- dnames
  dimnames(mtrx$west) <- dnames
  dimnames(mtrx$M) <- dnames
  dimnames(mtrx$mat) <- dnames
  dimnames(propM) <- dnames
  dimnames(propF) <- dnames
  
  dnames <- list(ages = ages, years = c(years), seasons = 1:nseason)
  dimnames(Catchobs) <- dnames
  
  if(is.null(dimnames(Surveyobs))){
    dnames <- list(ages = ages, year = c(years), survey = 1:nsurvey)
    dimnames(Surveyobs) <- dnames
  }
  # Some other things
  dimnames(effort.in) <- list(years = years, seasons = 1:nseason)
  dimnames(nocatch) <- list(years = years, seasons = 1:nseason)
  
  
  if (startYear > min(years)) {
    weca <- mtrx$weca[, c(years %in% startYear:max(years), TRUE), ]
    west <- mtrx$west[, c(years %in% startYear:max(years), TRUE), ]
    M <- mtrx$M[, c(years %in% startYear:max(years), TRUE), ]
    Mat <- mtrx$mat[, c(years %in% startYear:max(years), TRUE), ]
    propM <- propM[, c(years %in% startYear:max(years), TRUE), ]
    propF <- propF[, c(years %in% startYear:max(years), TRUE), ]
    
    Surveyobs <- Surveyobs[, which(years %in% startYear:max(years)), ]
    Catchobs <- Catchobs[, which(years %in% startYear:max(years)), ]
    
    scv <- scv[, which(years %in% startYear:max(years)), ]
    effort <- effort.in[which(years %in% startYear:max(years)), ]
    nocatch <- nocatch[which(years %in% startYear:max(years)), ]
    bidx <- bidx[which(years %in% startYear:max(years))]
    
    years <- startYear:max(years)
    nyears <- length(years)
  } else {
    weca <- mtrx$weca
    west <- mtrx$west
    M <- mtrx$M
    Mat <- mtrx$mat
    effort <- effort.in
  }
  
  
  if (endYear < max(years)) {
    weca <- mtrx$weca[, c(years %in% startYear:endYear, TRUE), , drop = FALSE]
    west <- mtrx$west[, c(years %in% startYear:endYear, TRUE), , drop = FALSE]
    M <- mtrx$M[, c(years %in% startYear:endYear, TRUE), , drop = FALSE]
    Mat <- mtrx$mat[, c(years %in% startYear:endYear, TRUE), , drop = FALSE]
    propM <- propM[, c(years %in% startYear:endYear, TRUE), , drop = FALSE]
    propF <- propF[, c(years %in% startYear:endYear, TRUE), , drop = FALSE]
    
    Surveyobs <- Surveyobs[, which(years %in% startYear:endYear), , drop = FALSE]
    Catchobs <- Catchobs[, which(years %in% startYear:endYear), , drop = FALSE]
    
    scv <- scv[, which(years %in% startYear:endYear), , drop = FALSE]
    effort <- effort.in[which(years %in% startYear:endYear), , drop = FALSE]
    nocatch <- nocatch[which(years %in% startYear:endYear), , drop = FALSE]
    bidx <- bidx[which(years %in% startYear:endYear), drop = FALSE]
    
    years <- startYear:endYear
    nyears <- length(years)
  }
  
  
  # Fill environmental matrix with 0's if its not there
  env_matrix <- matrix(0,  nenv,length(years))
  M_matrix <- matrix(0, 1, length(years))
  
  
  # Predator flag
  if(length(Pred_in) >  1){
    isPredator <- ncol(Pred_in)
  }else{
    isPredator <- 0
  }
  
  
  
  df.tmb <- list(
    weca = weca,
    west = west,
    Surveyobs = Surveyobs,
    Catchobs = Catchobs,
    propM = propM,
    propF = propF,
    no = no,
    years = years,
    age = ages,
    Fbarage = Fbarage,
    nage = length(ages),
    nseason = nseason,
    nyears = length(years),
    nsurvey = dim(Surveyobs)[3],
    recseason = recseason,
    useEffort = useEffort,
    estimateCreep = estimateCreep,
    effort = effort,
    bidx = bidx,
    useBlocks = useBlocks,
    blocks = blocks,
    Fminage = Fminage,
    Fmaxage = Fmaxage,
    Qminage = Qminage,
    Qmaxage = Qmaxage,
    Qlastage = Qlastage,
    Qidx = Qidx,
    Qidx_CV = Qidx.CV,
    Cidx_CV = Cidx.CV,
    catchSD = catchSDout,
    Midx_CV = Midx.CV,
    isFseason = isFseason, # Fishing mortality in how many quarterS? ,
    endFseason = endFseason,
    CminageSeason = CminageSeason,
    nocatch = nocatch,
    M = M,
    Pred_in = Pred_in,
    Mat = Mat,
    scv = scv,
    surveyStart = surveyStart,
    surveyEnd = surveyEnd, # c(0.1,1,0.001),
    surveySeason = surveySeason,
    minSDsurvey = minSDsurvey,
    minSDcatch = minSDcatch,
    maxSDcatch = maxSDcatch,
    catchSDin = catchSD,
    surveySD = surveySD,
    peneps = peneps,
    penepsC = penepsC,
    penepsCmax = penepsCmax,
    Mprior = Mprior,
    prior_SDM = prior_SDM,
    isPredator = isPredator,
    SDMprior = SDMprior,
    # nalphaM = nalphaM,
    powers = powersexp,
    recmodel = recmodel, # 1 is hockey stick
    estSD = estSD,
    SDmin = SDmin,
    betaSR = betaSR,
    nllfactor = nllfactor,
    randomF = randomF,
    randomR = randomR,
    randomM = randomM,
    nrandM =  length(unique(Midx.CV[Midx.CV > -1])),
    nenv = nenv,
    env_matrix = env_matrix,# Number of environmental parameters,
    M_matrix = M_matrix
  )
  
  # Check if everything looks right
  check_tmb_error(df.tmb)
  
  return(df.tmb)
}